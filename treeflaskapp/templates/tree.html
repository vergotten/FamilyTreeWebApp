{% extends "user_panel.html" %}

{% block content %}

<style type="text/css">
    #treeContainer {
        width: auto;
        height: 95%;
        border: 1px solid lightgray;
    }

    #treeContainer .node .field_0 {
        font-size: 24px;  // Adjust as needed
        white-space: normal;  // Allows the text to wrap to the next line
        text-align: center;  // Centers the text
    }
    #treeContainer .node img {
        width: 100px;  // Adjust as needed
        height: 100px;  // Adjust as needed
    }
</style>

<script src="https://balkangraph.com/js/latest/OrgChart.js"></script>
<script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<script src="https://balkan.app/js/familytree.js"></script>

<div class="container" style="height: 100vh;">
    <div class="form-container bg-light p-2 rounded" style="height: 100%;">
        <!-- Flash message handler -->
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                {% for category, message in messages %}
                    <div class="alert alert-{{ category }}">
                        {{ message }}
                    </div>
                {% endfor %}
            {% endif %}
        {% endwith %}
        {% if persons %}
            <!-- Add radio buttons for tree selection -->
            <div style="display: flex; gap: 10px;">
                <div>
                    <input type="radio" id="tree1" name="tree" checked>
                    <label for="tree1">
                        {% if g.user_language == 'en' %}
                                        Tree 1
                                    {% elif g.user_language == 'ru' %}
                                        Дерево 1
                                    {% endif %}
                    </label>
                </div>
                <div>
                    <input type="radio" id="tree2" name="tree">
                    <label for="tree2">
                        {% if g.user_language == 'en' %}
                                        Tree 2
                                    {% elif g.user_language == 'ru' %}
                                        Дерево 2
                                    {% endif %}
                    </label>
                </div>
            </div>
            <div id="treeContainer"></div>

        {% else %}
        {% if g.user_language == 'en' %}
            <p>No records in database. <a href="{{ url_for('persons.create_person', username=session['username']) }}">Create new</a></p>
        {% elif g.user_language == 'ru' %}
            <p>Нет записей в базе данных. <a href="{{ url_for('persons.create_person', username=session['username']) }}">Создать новую</a></p>
        {% endif %}
    {% endif %}
    </div>
</div>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

<script type="text/javascript">
    var persons_data = {{ persons_data|tojson }};
    console.log('Persons data:', persons_data);  // Debug line

    // Create the chart container
    var container = document.getElementById('treeContainer');

    // Check which radio button is selected
    var tree1 = document.getElementById('tree1');
    var tree2 = document.getElementById('tree2');

    // Add event listeners to the radio buttons
    tree1.addEventListener('change', updateChart);
    tree2.addEventListener('change', updateChart);

    // Function to update the chart
    function updateChart() {
        // Clear the existing chart
        while (container.firstChild) {
            container.firstChild.remove();
        }

        // Define a variable to control whether to show dummy nodes
        var showDummies = true;  // Change this to false if you don't want to show dummy nodes

        ////////////////////////////////////////////////////////////////////////////////////////////////

        // Check if tree1 is checked
        if (tree1.checked) {
            // Log the original data
            console.log('Original data:', persons_data);

            // Get all the ids
            var ids = persons_data.map(function(person) {
                return person.id;
            });

            // Preprocess the data
            var preprocessedData = persons_data.map(function(person) {
                // If the person has a spouse but no parents
                if (Number.isInteger(person.spouse_id) && ![null, "None"].includes(person.mother_id) && ![null, "None"].includes(person.father_id)) {
                    // Find the spouse in the data
                    var spouse = persons_data.find(p => p.id === person.spouse_id);

                    // If the spouse exists and has parents, assign the person the same parent IDs as their spouse
                    if (spouse && (spouse.mother_id || spouse.father_id)) {
                        person.mother_id = spouse.mother_id;
                        person.father_id = spouse.father_id;
                    }
                }

                return person;
            });

            // Transform the preprocessed data into a format suitable for the tree visualization, creating a node for each person
            var nodes = persons_data.map(function(person) {
                // Skip if the person is a dummy and showDummies is false
                if (person.id < 0 && !showDummies) {
                    return null;
                }

                // Prepare the node data
                var node = {
                    id: person.id ? person.id : 'unknown',
                    name: person.name ? person.name : 'unknown',
                    img: person.img ? person.img : "/static/images/no-user-photo.png"
                };

                // Check if person.extra.gender is "Male" or "Female", then set node.gender
                if (person.extra && person.extra.gender) {
                    if (person.extra.gender === 'Male' || person.extra.gender === 'Female') {
                        node.gender = person.extra.gender.toLowerCase();
                    }
                }

                // Add mother id to mid if it exists and corresponds to another person's id
                if (person.mother_id && person.mother_id !== 'None' && ids.includes(person.mother_id)) {
                    node.mid = [person.mother_id];
                }

                // Add father id to fid if it exists and corresponds to another person's id
                if (person.father_id && person.father_id !== 'None' && ids.includes(person.father_id)) {
                    node.fid = [person.father_id];
                }

                // Add partners to pids if they exist and each one corresponds to another person's id
                if (person.partners && person.partners !== 'None') {
                    node.pids = person.partners.flat().filter(partner_id => ids.includes(partner_id));
                }

                return node;
            }).filter(Boolean);  // This will remove null values from the nodes array

            // Log the transformed data
            console.log('Transformed data:', nodes);

            // Prepare the edges
            var edges = persons_data.flatMap(function(person) {
                var personEdges = [];

                // Add an edge for each partner if they exist and correspond to another person's id
                if (person.partners && person.partners !== 'None') {
                    person.partners.flat().filter(partner_id => ids.includes(partner_id)).forEach(function(partner_id) {
                        // Only create an edge if person.id < partner_id
                        if (person.id < partner_id) {
                            // Create an edge for each pair of partners
                            personEdges.push({
                                from: person.id,
                                to: partner_id
                            });
                            console.log('Creating edge:', {from: person.id, to: partner_id});  // Log each edge as it's created
                        }
                    });
                }

                return personEdges;
            });

            // Log the edges
            console.log('Edges:', edges);

            FamilyTree.templates.field_0 = '<text style="font-size: 24px;" fill="#ffffff" x="100" y="90" text-anchor="middle">{val}</text>';

            // Create the FamilyTree chart with your new settings
            var chart = new FamilyTree(document.getElementById("treeContainer"), {
                mouseScrool: FamilyTree.none,
                minPartnerSeparation: 150,
                siblingSeparation: 150,
                template: 'tommy',
                nodeBinding: {
                    field_0: "name",
                    field_1: "title",
                    img_0: "img",
                },
                nodes: nodes
            });

        ////////////////////////////////////////////////////////////////////////////////////////////////

        } else if (tree2.checked) {
            // Log the original data
            console.log('Original data:', persons_data);

            // Get all the ids
            var ids = persons_data.map(function(person) {
                return person.id;
            });

            // Preprocess the data
            var preprocessedData = persons_data.map(function(person) {
                // If the person has a spouse but no parents
                if (Number.isInteger(person.spouse_id) && ![null, "None"].includes(person.mother_id) && ![null, "None"].includes(person.father_id)) {
                    // Find the spouse in the data
                    var spouse = persons_data.find(p => p.id === person.spouse_id);

                    // If the spouse exists and has parents, assign the person the same parent IDs as their spouse
                    if (spouse && (spouse.mother_id || spouse.father_id)) {
                        person.mother_id = spouse.mother_id;
                        person.father_id = spouse.father_id;
                    }
                }

                return person;
            });

            // Transform the preprocessed data into a format suitable for the tree visualization, creating a node for each person
            var nodes = persons_data.map(function(person) {
                // Skip if the person is a dummy and showDummies is false
                if (person.id < 0 && !showDummies) {
                    return null;
                }

                // Prepare the node data
                var node = {
                    id: person.id ? person.id : 'unknown',
                    name: person.name ? person.name : 'unknown',
                    img: person.img ? person.img : "/static/images/no-user-photo.png"
                };

                // Check if person.extra.gender is "Male" or "Female", then set node.gender
                if (person.extra && person.extra.gender) {
                    if (person.extra.gender === 'Male' || person.extra.gender === 'Female') {
                        node.gender = person.extra.gender.toLowerCase();
                    }
                }

                // Add mother id to mid if it exists and corresponds to another person's id
                if (person.mother_id && person.mother_id !== 'None' && ids.includes(person.mother_id)) {
                    node.mid = [person.mother_id];
                }

                // Add father id to fid if it exists and corresponds to another person's id
                if (person.father_id && person.father_id !== 'None' && ids.includes(person.father_id)) {
                    node.fid = [person.father_id];
                }

                // Add partners to pids if they exist and each one corresponds to another person's id
                if (person.partners && person.partners !== 'None') {
                    node.pids = person.partners.flat().filter(partner_id => ids.includes(partner_id));
                }

                return node;
            }).filter(Boolean);  // This will remove null values from the nodes array

            // Log the transformed data
            console.log('Transformed data:', nodes);

            // Prepare the edges
            var edges = persons_data.flatMap(function(person) {
                var personEdges = [];

                // Add an edge for each partner if they exist and correspond to another person's id
                if (person.partners && person.partners !== 'None') {
                    person.partners.flat().filter(partner_id => ids.includes(partner_id)).forEach(function(partner_id) {
                        // Only create an edge if person.id < partner_id
                        if (person.id < partner_id) {
                            // Create an edge for each pair of partners
                            personEdges.push({
                                from: person.id,
                                to: partner_id
                            });
                            console.log('Creating edge:', {from: person.id, to: partner_id});  // Log each edge as it's created
                        }
                    });
                }

                return personEdges;
            });

            // Log the edges
            console.log('Edges:', edges);

            FamilyTree.templates.field_0 = '<text style="font-size: 24px;" fill="#ffffff" x="100" y="90" text-anchor="middle">{val}</text>';

            // Create the FamilyTree chart with your new settings
            var chart = new FamilyTree(document.getElementById("treeContainer"), {
                mouseScrool: FamilyTree.none,
                minPartnerSeparation: 150,
                siblingSeparation: 150,
                template: 'john',
                nodeBinding: {
                    field_0: "name",
                    field_1: "title",
                    img_0: "img",
                },
                nodes: nodes
            });

            ////////////////////////////////////////////////////////////////////////////
        } else {
            console.log('No tree selected');
        }
    }

    // Create the initial chart
    updateChart();

</script>

{% endblock %}